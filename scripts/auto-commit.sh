#!/usr/bin/env bash
#
# auto-commit.sh - Automatically commit file changes with AI-generated messages
#
# This hook runs after Write/Edit/Bash tools complete, automatically committing
# each file change with a descriptive commit message generated by Claude Code.
#
# INSTALLATION:
#
# Method 1: Plugin Installation (Recommended)
#   /plugin marketplace add jarosser06/always-commit
#   /plugin install always-commit@jarosser06/always-commit
#   Hook automatically activates when plugin is enabled.
#
# Method 2: Project-Based (For development/customization)
#   1. Make this script executable: chmod +x scripts/auto-commit.sh
#   2. Create symlink: ln -s ../../scripts/auto-commit.sh .claude/hooks/auto-commit.sh
#   3. Add to .claude/settings.json:
#      {
#        "hooks": {
#          "PostToolUse": [{
#            "matcher": "Write|Edit|Bash",
#            "hooks": [{
#              "type": "command",
#              "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/auto-commit.sh",
#              "timeout": 30
#            }]
#          }]
#        }
#      }
#   4. Restart Claude Code session
#
# ENVIRONMENT VARIABLES:
#   CLAUDE_AUTO_COMMIT_ALLOW_MAIN  - Set to "true" to allow commits on main (default: false)
#   CLAUDE_AUTO_COMMIT_SKIP        - Set to "true" to disable auto-commit entirely
#   CLAUDE_AUTO_COMMIT_USE_AI      - Set to "true" to use AI-generated messages (default: false)
#
# BEHAVIOR:
#   - Commits each file change individually
#   - Uses simple commit messages by default
#   - Set CLAUDE_AUTO_COMMIT_USE_AI=true for AI-generated messages (requires Claude Code CLI)
#   - Blocks commits on main branch by default (configurable)
#   - Respects .gitignore patterns automatically
#   - Skips sensitive files (.claude/settings.local.json, etc.)
#   - Always exits 0 (never blocks Claude Code)
#
# SQUASHING COMMITS:
#   Use the companion script to squash all auto-commits:
#   ./scripts/squash-auto-commits.sh
#

set -euo pipefail

# Configuration
MAX_DIFF_LINES=100  # Limit diff context sent to Claude

# Skip if auto-commit disabled
if [ "${CLAUDE_AUTO_COMMIT_SKIP:-false}" = "true" ]; then
  exit 0
fi

# Read hook input from stdin
input=$(cat)

# Extract relevant data from hook event
tool_name=$(echo "$input" | jq -r '.tool_name // "Unknown"')
file_path=$(echo "$input" | jq -r '.tool_input.file_path // empty')

# Skip if no file path (shouldn't happen, but be safe)
if [ -z "$file_path" ]; then
  exit 0
fi

# Detect context: plugin mode or project-based mode
# In plugin mode: CLAUDE_PLUGIN_ROOT is set, use CLAUDE_PROJECT_DIR for git operations
# In project mode: Only CLAUDE_PROJECT_DIR is set
if [ -n "${CLAUDE_PLUGIN_ROOT:-}" ]; then
  # Plugin mode: working directory is the user's project
  project_dir="${CLAUDE_PROJECT_DIR}"
else
  # Project-based mode: working directory is where the hook is installed
  project_dir="${CLAUDE_PROJECT_DIR}"
fi

# Change to project directory
cd "$project_dir" || exit 0

# Get relative path from project root
if [[ "$file_path" == "$project_dir"* ]]; then
  relative_path="${file_path#$project_dir/}"
else
  relative_path="$file_path"
fi

# Skip patterns (in addition to .gitignore)
skip_patterns=(
  ".claude/settings.local.json"
  ".git/"
  ".drift.yaml"
  "node_modules/"
  ".venv/"
  "venv/"
  "__pycache__/"
  ".pytest_cache/"
  "*.pyc"
  ".coverage"
  "htmlcov/"
)

# Check if file should be skipped
should_skip=false
for pattern in "${skip_patterns[@]}"; do
  if [[ "$relative_path" == *"$pattern"* ]] || [[ "$relative_path" == $pattern ]]; then
    should_skip=true
    break
  fi
done

if [ "$should_skip" = true ]; then
  exit 0
fi

# Check current branch and enforce main protection
current_branch=$(git branch --show-current 2>/dev/null || echo "")

if [ "$current_branch" = "main" ]; then
  if [ "${CLAUDE_AUTO_COMMIT_ALLOW_MAIN:-false}" != "true" ]; then
    # Use JSON output to show warning in Claude (PostToolUse hooks: exit 0 ignores stderr)
    cat <<EOF
{
  "systemMessage": "⚠️  Auto-commit skipped: on main branch (set CLAUDE_AUTO_COMMIT_ALLOW_MAIN=true to override)",
  "suppressOutput": false
}
EOF
    exit 0
  fi
fi

# Check if file exists (might have been deleted)
if [ ! -f "$relative_path" ]; then
  exit 0
fi

# Check if file has changes (staged or unstaged)
if git diff --quiet "$relative_path" 2>/dev/null && git diff --cached --quiet "$relative_path" 2>/dev/null; then
  # No changes to commit
  exit 0
fi

# Add the file to staging
git add "$relative_path" 2>/dev/null || exit 0

# Check if there are staged changes after add (respects .gitignore)
if git diff --cached --quiet 2>/dev/null; then
  # No staged changes (likely .gitignored)
  exit 0
fi

# Generate commit message
commit_msg=""

# Try AI-generated message using local Claude Code if enabled
if [ "${CLAUDE_AUTO_COMMIT_USE_AI:-false}" = "true" ] && command -v claude &> /dev/null; then
  # Get git diff for context
  diff_output=$(git diff --cached "$relative_path" 2>/dev/null | head -n "$MAX_DIFF_LINES" || echo "")

  # Truncate diff if too long
  if [ $(echo "$diff_output" | wc -l) -ge "$MAX_DIFF_LINES" ]; then
    diff_output="$diff_output\n... (diff truncated)"
  fi

  # Get file extension for context
  file_ext="${relative_path##*.}"

  # Build prompt for Claude
  prompt="Generate a concise git commit message (one line, max 72 chars) for this change.

Tool: $tool_name
File: $relative_path
Extension: $file_ext

Changes:
$diff_output

Format: <type>(<scope>): <description>
Types: feat, fix, docs, style, refactor, test, chore
Be specific about what changed, not just \"update file\".
Output only the commit message, nothing else."

  # Call Claude Code CLI in headless mode with MCP disabled
  commit_msg=$(claude -p "$prompt" \
    --model haiku \
    --output-format json \
    --mcp-config '{"mcpServers":{}}' \
    --strict-mcp-config \
    2>/dev/null | jq -r '.result // .response // .content // .text // .' 2>/dev/null | head -n 1 || echo "")

  # Trim whitespace and quotes
  commit_msg=$(echo "$commit_msg" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^"//' -e 's/"$//')
fi

# Fallback to simple message if Claude failed or disabled
if [ -z "$commit_msg" ]; then
  basename=$(basename "$relative_path")
  commit_msg="chore($tool_name): auto-commit $basename"
fi

# Commit the file
if git commit -m "$commit_msg" 2>/dev/null; then
  echo "✓ Auto-committed: $relative_path" >&2
  echo "  Message: $commit_msg" >&2
else
  # Commit failed (shouldn't happen, but handle gracefully)
  git reset HEAD "$relative_path" 2>/dev/null || true
fi

# Always exit 0 (never block Claude Code)
exit 0
